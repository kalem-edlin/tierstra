'ISSUE001':
Need to know how to remove the first unused parameter from a function

'ISSUE002':
Perhaps an Error handling framework should be created for issues (alert or console error?)
EG throw new ExportError.nodeMissing

'ISSUE003':
Value should be the name of the tile (when information like that is carried)

'ISSUE004':
Where can I position constants so other files (dragActions) can refer to things like DELETE_TILE_DROPPABLE_ID?

'ISSUE005':
Deep copies using JSON serialization is needed as examples hold their state when the same one is reloaded! (issues when deleting)

'ISSUE006':
removing overflow-x: scroll; will make the scroll bar only show for rows with full content. However this makes rows look uneven. Needs a fix!

'ISSUE007':
Not reeeally sure whats going on with the 0px width. Kinda forgot. Could be causing complications further down. Not worth fixing until proposed scroll alternative fix

'ISSUE008':
 The styling (sx, styles etc) logic with the calculations looks better in the return render part than in styled(component)s 
 - alternative styling pattern case (PLZ REVIEW)

'ISSUE009':
I had to use a callback function that would not recalculate itself in the canvas useEffect for updating exports. 
This begs the question: Is there anyway to make sure Tierlist Data or  tileLength is only if it has changed? Will this save performance
Callbacks are also generally used to increase performance. Where else can I use these? Im sure alot of updating is happening when dragging something. Performance gains?
TLDR: why would I NOT use a callback in place of my functions dealing with states
- Use it when children are re-rendering themselves too much because of functions re-calculating themselves (long lists of prop functions)

'ISSUE010':
The network logic for the appconfig fetching should be moved into a networking layer when a backend is introduced

'ISSUE011':
This whole Config class could have just as easily been implemented with functional programming to keep up with the patterns of the app itself. 
However, the goal of the AppConfig is to make it as easy as possible for developers to add config items to the project and not worry too much about 
how the debug drawer, or contexts would work in the background. An OOP method of design seemed to best accomodate this using an extension of Config
to hide its inner workings and leave the devs with a simple interface to add config items + 
prevents a ton of imports into the app (EG all the functions used in config)
I tried to make items in the Config class immutable to align better with Functional programming rules that the class must adhere to within the app 
returning a new App Config with a deep copy of items each time they must be changed for the app's Set State pattern.

'ISSUE012':
https://www.petermorlion.com/iterating-a-typescript-enum/ 
I can implement this in a potentially smarter way. Type script Enums can be enumerated to get their case string representatino which could replace string options.
I could also look into using properties as config items instead of a Record by converting the properties to JSON and mapping values and then converting back to app Config with typescripts record conversion

'ISSUE013':
This is done in the Config class but with a key. Should I implement a ConfigItem class that implements its own getValue => value ?? default (can use this in Config get())